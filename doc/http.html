<!DOCTYPE html>

<html>
<head>
  <title>Public API</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="http.html">
                  http.js
                </a>
              
                
                <a class="source" href="index.html">
                  index.js
                </a>
              
              <a class="source" href="protocol/index.html">Protocol</a>
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="public-api">Public API</h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>The main governing power behind the http2 API design is that it should look very similar to the
existing node.js [HTTPS API][1] (which is, in turn, almost identical to the [HTTP API][2]). The
additional features of HTTP/2 are exposed as extensions to this API. Furthermore, node-http2
should fall back to using HTTP/1.1 if needed. Compatibility with undocumented or deprecated
elements of the node.js HTTP/HTTPS API is a non-goal.</p>
<h2 id="additional-and-modified-api-elements">Additional and modified API elements</h2>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <ul>
<li><p><strong>Class: http2.Endpoint</strong>: an API for using the raw HTTP/2 framing layer. For documentation
see <a href="protocol/endpoint.html">protocol/endpoint.js</a>.</p>
</li>
<li><p><strong>Class: http2.Server</strong></p>
<ul>
<li><strong>Event: ‘connection’ (socket, [endpoint])</strong>: there’s a second argument if the negotiation of
HTTP/2 was successful: the reference to the <a href="protocol/endpoint.html">Endpoint</a> object tied to the
socket.</li>
</ul>
</li>
<li><p><strong>http2.createServer(options, [requestListener])</strong>: additional option:</p>
<ul>
<li><strong>log</strong>: an optional <a href="https://github.com/trentm/node-bunyan">bunyan</a> logger object</li>
</ul>
</li>
<li><p><strong>Class: http2.ServerResponse</strong></p>
<ul>
<li><strong>response.push(options)</strong>: initiates a server push. <code>options</code> describes the ‘imaginary’
request to which the push stream is a response; the possible options are identical to the
ones accepted by <code>http2.request</code>. Returns a ServerResponse object that can be used to send
the response headers and content.</li>
</ul>
</li>
<li><p><strong>Class: http2.Agent</strong></p>
<ul>
<li><strong>new Agent(options)</strong>: additional option:<ul>
<li><strong>log</strong>: an optional <a href="https://github.com/trentm/node-bunyan">bunyan</a> logger object</li>
</ul>
</li>
<li><strong>agent.sockets</strong>: only contains TCP sockets that corresponds to HTTP/1 requests.</li>
<li><strong>agent.endpoints</strong>: contains <a href="protocol/endpoint.html">Endpoint</a> objects for HTTP/2 connections.</li>
</ul>
</li>
<li><p><strong>http2.request(options, [callback])</strong>:</p>
<ul>
<li>similar to http.request</li>
</ul>
</li>
<li><p><strong>http2.get(options, [callback])</strong>:</p>
<ul>
<li>similar to http.get</li>
</ul>
</li>
<li><p><strong>Class: http2.ClientRequest</strong></p>
<ul>
<li><strong>Event: ‘socket’ (socket)</strong>: in case of an HTTP/2 incoming message, <code>socket</code> is a reference
to the associated <a href="protocol/stream.html">HTTP/2 Stream</a> object (and not to the TCP socket).</li>
<li><strong>Event: ‘push’ (promise)</strong>: signals the intention of a server push associated to this
request. <code>promise</code> is an IncomingPromise. If there’s no listener for this event, the server
push is cancelled.</li>
<li><strong>request.setPriority(priority)</strong>: assign a priority to this request. <code>priority</code> is a number
between 0 (highest priority) and 2^31-1 (lowest priority). Default value is 2^30.</li>
</ul>
</li>
<li><p><strong>Class: http2.IncomingMessage</strong></p>
<ul>
<li>has two subclasses for easier interface description: <strong>IncomingRequest</strong> and
<strong>IncomingResponse</strong></li>
<li><strong>message.socket</strong>: in case of an HTTP/2 incoming message, it’s a reference to the associated
<a href="protocol/stream.html">HTTP/2 Stream</a> object (and not to the TCP socket).</li>
</ul>
</li>
<li><p><strong>Class: http2.IncomingRequest (IncomingMessage)</strong></p>
<ul>
<li><strong>message.url</strong>: in case of an HTTP/2 incoming request, the <code>url</code> field always contains the
path, and never a full url (it contains the path in most cases in the HTTPS api as well).</li>
<li><strong>message.scheme</strong>: additional field. Mandatory HTTP/2 request metadata.</li>
<li><strong>message.host</strong>: additional field. Mandatory HTTP/2 request metadata. Note that this
replaces the old Host header field, but node-http2 will add Host to the <code>message.headers</code> for
backwards compatibility.</li>
</ul>
</li>
<li><p><strong>Class: http2.IncomingPromise (IncomingRequest)</strong></p>
<ul>
<li>contains the metadata of the ‘imaginary’ request to which the server push is an answer.</li>
<li><strong>Event: ‘response’ (response)</strong>: signals the arrival of the actual push stream. <code>response</code>
is an IncomingResponse.</li>
<li><strong>Event: ‘push’ (promise)</strong>: signals the intention of a server push associated to this
request. <code>promise</code> is an IncomingPromise. If there’s no listener for this event, the server
push is cancelled.</li>
<li><strong>promise.cancel()</strong>: cancels the promised server push.</li>
<li><strong>promise.setPriority(priority)</strong>: assign a priority to this push stream. <code>priority</code> is a
number between 0 (highest priority) and 2^31-1 (lowest priority). Default value is 2^30.</li>
</ul>
</li>
</ul>
<h2 id="api-elements-not-yet-implemented">API elements not yet implemented</h2>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <ul>
<li><strong>Class: http2.Server</strong><ul>
<li><strong>server.maxHeadersCount</strong></li>
</ul>
</li>
</ul>
<h2 id="api-elements-that-are-not-applicable-to-http-2">API elements that are not applicable to HTTP/2</h2>

            </div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>The reason may be deprecation of certain HTTP/1.1 features, or that some API elements simply
don’t make sense when using HTTP/2. These will not be present when a request is done with HTTP/2,
but will function normally when falling back to using HTTP/1.1.</p>
<ul>
<li><p><strong>Class: http2.Server</strong></p>
<ul>
<li><strong>Event: ‘checkContinue’</strong>: not in the spec</li>
<li><strong>Event: ‘upgrade’</strong>: upgrade is deprecated in HTTP/2</li>
<li><strong>Event: ‘timeout’</strong>: HTTP/2 sockets won’t timeout because of application level keepalive
(PING frames)</li>
<li><strong>Event: ‘connect’</strong>: not yet supported</li>
<li><strong>server.setTimeout(msecs, [callback])</strong></li>
<li><strong>server.timeout</strong></li>
</ul>
</li>
<li><p><strong>Class: http2.ServerResponse</strong></p>
<ul>
<li><strong>Event: ‘close’</strong></li>
<li><strong>Event: ‘timeout’</strong></li>
<li><strong>response.writeContinue()</strong></li>
<li><strong>response.writeHead(statusCode, [reasonPhrase], [headers])</strong>: reasonPhrase will always be
ignored since <a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.4">it’s not supported in HTTP/2</a></li>
<li><strong>response.setTimeout(timeout, [callback])</strong></li>
</ul>
</li>
<li><p><strong>Class: http2.Agent</strong></p>
<ul>
<li><strong>agent.maxSockets</strong>: only affects HTTP/1 connection pool. When using HTTP/2, there’s always
one connection per host.</li>
</ul>
</li>
<li><p><strong>Class: http2.ClientRequest</strong></p>
<ul>
<li><strong>Event: ‘upgrade’</strong></li>
<li><strong>Event: ‘connect’</strong></li>
<li><strong>Event: ‘continue’</strong></li>
<li><strong>request.setTimeout(timeout, [callback])</strong></li>
<li><strong>request.setNoDelay([noDelay])</strong></li>
<li><strong>request.setSocketKeepAlive([enable], [initialDelay])</strong></li>
</ul>
</li>
<li><p><strong>Class: http2.IncomingMessage</strong></p>
<ul>
<li><strong>Event: ‘close’</strong></li>
<li><strong>message.setTimeout(timeout, [callback])</strong></li>
</ul>
</li>
</ul>

            </div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h1 id="common-server-and-client-side-code">Common server and client side code</h1>

            </div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>);
<span class="hljs-keyword">var</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>);
<span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);
<span class="hljs-keyword">var</span> EventEmitter = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>).EventEmitter;
<span class="hljs-keyword">var</span> PassThrough = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>).PassThrough;
<span class="hljs-keyword">var</span> Readable = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>).Readable;
<span class="hljs-keyword">var</span> Writable = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>).Writable;
<span class="hljs-keyword">var</span> protocol = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./protocol'</span>);
<span class="hljs-keyword">var</span> Endpoint = protocol.Endpoint;
<span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">var</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">'https'</span>);

exports.STATUS_CODES = http.STATUS_CODES;
exports.IncomingMessage = IncomingMessage;
exports.OutgoingMessage = OutgoingMessage;
exports.protocol = protocol;

<span class="hljs-keyword">var</span> deprecatedHeaders = [
  <span class="hljs-string">'connection'</span>,
  <span class="hljs-string">'host'</span>,
  <span class="hljs-string">'keep-alive'</span>,
  <span class="hljs-string">'proxy-connection'</span>,
  <span class="hljs-string">'transfer-encoding'</span>,
  <span class="hljs-string">'upgrade'</span>
];</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>When doing NPN/ALPN negotiation, HTTP/1.1 is used as fallback</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> supportedProtocols = [protocol.VERSION, <span class="hljs-string">'http/1.1'</span>, <span class="hljs-string">'http/1.0'</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Ciphersuite list based on the recommendations of <a href="https://wiki.mozilla.org/Security/Server_Side_TLS">https://wiki.mozilla.org/Security/Server_Side_TLS</a>
The only modification is that kEDH+AESGCM were placed after DHE and ECDHE suites</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> cipherSuites = [
  <span class="hljs-string">'ECDHE-RSA-AES128-GCM-SHA256'</span>,
  <span class="hljs-string">'ECDHE-ECDSA-AES128-GCM-SHA256'</span>,
  <span class="hljs-string">'ECDHE-RSA-AES256-GCM-SHA384'</span>,
  <span class="hljs-string">'ECDHE-ECDSA-AES256-GCM-SHA384'</span>,
  <span class="hljs-string">'DHE-RSA-AES128-GCM-SHA256'</span>,
  <span class="hljs-string">'DHE-DSS-AES128-GCM-SHA256'</span>,
  <span class="hljs-string">'ECDHE-RSA-AES128-SHA256'</span>,
  <span class="hljs-string">'ECDHE-ECDSA-AES128-SHA256'</span>,
  <span class="hljs-string">'ECDHE-RSA-AES128-SHA'</span>,
  <span class="hljs-string">'ECDHE-ECDSA-AES128-SHA'</span>,
  <span class="hljs-string">'ECDHE-RSA-AES256-SHA384'</span>,
  <span class="hljs-string">'ECDHE-ECDSA-AES256-SHA384'</span>,
  <span class="hljs-string">'ECDHE-RSA-AES256-SHA'</span>,
  <span class="hljs-string">'ECDHE-ECDSA-AES256-SHA'</span>,
  <span class="hljs-string">'DHE-RSA-AES128-SHA256'</span>,
  <span class="hljs-string">'DHE-RSA-AES128-SHA'</span>,
  <span class="hljs-string">'DHE-DSS-AES128-SHA256'</span>,
  <span class="hljs-string">'DHE-RSA-AES256-SHA256'</span>,
  <span class="hljs-string">'DHE-DSS-AES256-SHA'</span>,
  <span class="hljs-string">'DHE-RSA-AES256-SHA'</span>,
  <span class="hljs-string">'kEDH+AESGCM'</span>,
  <span class="hljs-string">'AES128-GCM-SHA256'</span>,
  <span class="hljs-string">'AES256-GCM-SHA384'</span>,
  <span class="hljs-string">'ECDHE-RSA-RC4-SHA'</span>,
  <span class="hljs-string">'ECDHE-ECDSA-RC4-SHA'</span>,
  <span class="hljs-string">'AES128'</span>,
  <span class="hljs-string">'AES256'</span>,
  <span class="hljs-string">'RC4-SHA'</span>,
  <span class="hljs-string">'HIGH'</span>,
  <span class="hljs-string">'!aNULL'</span>,
  <span class="hljs-string">'!eNULL'</span>,
  <span class="hljs-string">'!EXPORT'</span>,
  <span class="hljs-string">'!DES'</span>,
  <span class="hljs-string">'!3DES'</span>,
  <span class="hljs-string">'!MD5'</span>,
  <span class="hljs-string">'!PSK'</span>
].join(<span class="hljs-string">':'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h2 id="logging">Logging</h2>

            </div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Logger shim, used when no logger is provided by the user.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noop</span>(<span class="hljs-params"></span>) </span>{}
<span class="hljs-keyword">var</span> defaultLogger = {
  fatal: noop,
  error: noop,
  warn : noop,
  info : noop,
  debug: noop,
  trace: noop,

  child: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Bunyan serializers exported by submodules that are worth adding when creating a logger.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.serializers = protocol.serializers;</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h2 id="incomingmessage-class">IncomingMessage class</h2>

            </div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IncomingMessage</span>(<span class="hljs-params">stream</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <ul>
<li>This is basically a read-only wrapper for the <a href="protocol/stream.html">Stream</a> class.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  PassThrough.call(<span class="hljs-keyword">this</span>);
  stream.pipe(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">this</span>.socket = <span class="hljs-keyword">this</span>.stream = stream;

  <span class="hljs-keyword">this</span>._log = stream._log.child({ component: <span class="hljs-string">'http'</span> });</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <ul>
<li>HTTP/2.0 does not define a way to carry the version identifier that is included in the
HTTP/1.1 request/status line. Version is always 2.0.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.httpVersion = <span class="hljs-string">'2.0'</span>;
  <span class="hljs-keyword">this</span>.httpVersionMajor = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">this</span>.httpVersionMinor = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <ul>
<li><code>this.headers</code> will store the regular headers (and none of the special colon headers)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.headers = {};
  <span class="hljs-keyword">this</span>.trailers = <span class="hljs-literal">undefined</span>;
  <span class="hljs-keyword">this</span>._lastHeadersSeen = <span class="hljs-literal">undefined</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <ul>
<li>Other metadata is filled in when the headers arrive.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  stream.once(<span class="hljs-string">'headers'</span>, <span class="hljs-keyword">this</span>._onHeaders.bind(<span class="hljs-keyword">this</span>));
  stream.once(<span class="hljs-string">'end'</span>, <span class="hljs-keyword">this</span>._onEnd.bind(<span class="hljs-keyword">this</span>));
}
IncomingMessage.prototype = <span class="hljs-built_in">Object</span>.create(PassThrough.prototype, { constructor: { value: IncomingMessage } });</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p><a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.3">Request Header Fields</a></p>
<ul>
<li><code>headers</code> argument: HTTP/2.0 request and response header fields carry information as a series
of key-value pairs. This includes the target URI for the request, the status code for the
response, as well as HTTP header fields.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>IncomingMessage.prototype._onHeaders = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_onHeaders</span>(<span class="hljs-params">headers</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <ul>
<li>Detects malformed headers</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>._validateHeaders(headers);</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <ul>
<li>Store the <em>regular</em> headers in <code>this.headers</code></li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> headers) {
    <span class="hljs-keyword">if</span> (name[<span class="hljs-number">0</span>] !== <span class="hljs-string">':'</span>) {
      <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'set-cookie'</span> &amp;&amp; !<span class="hljs-built_in">Array</span>.isArray(headers[name])) {
        <span class="hljs-keyword">this</span>.headers[name] = [headers[name]];
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.headers[name] = headers[name];
      }
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <ul>
<li>The last header block, if it’s not the first, will represent the trailers</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">this</span>.stream.on(<span class="hljs-string">'headers'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">headers</span>) </span>{
    self._lastHeadersSeen = headers;
  });
};

IncomingMessage.prototype._onEnd = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_onEnd</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.trailers = <span class="hljs-keyword">this</span>._lastHeadersSeen;
};

IncomingMessage.prototype.setTimeout = noop;

IncomingMessage.prototype._checkSpecialHeader = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_checkSpecialHeader</span>(<span class="hljs-params">key, value</span>) </span>{
  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'string'</span>) || (value.length === <span class="hljs-number">0</span>)) {
    <span class="hljs-keyword">this</span>._log.error({ key: key, value: value }, <span class="hljs-string">'Invalid or missing special header field'</span>);
    <span class="hljs-keyword">this</span>.stream.reset(<span class="hljs-string">'PROTOCOL_ERROR'</span>);
  }

  <span class="hljs-keyword">return</span> value;
};

IncomingMessage.prototype._validateHeaders = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_validateHeaders</span>(<span class="hljs-params">headers</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <ul>
<li>An HTTP/2.0 request or response MUST NOT include any of the following header fields:
Connection, Host, Keep-Alive, Proxy-Connection, Transfer-Encoding, and Upgrade. A server
MUST treat the presence of any of these header fields as a stream error of type
PROTOCOL_ERROR.
If the TE header is present, it’s only valid value is ‘trailers’</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; deprecatedHeaders.length; i++) {
    <span class="hljs-keyword">var</span> key = deprecatedHeaders[i];
    <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> headers || (key === <span class="hljs-string">'te'</span> &amp;&amp; headers[key] !== <span class="hljs-string">'trailers'</span>)) {
      <span class="hljs-keyword">this</span>._log.error({ key: key, value: headers[key] }, <span class="hljs-string">'Deprecated header found'</span>);
      <span class="hljs-keyword">this</span>.stream.reset(<span class="hljs-string">'PROTOCOL_ERROR'</span>);
      <span class="hljs-keyword">return</span>;
    }
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> headerName <span class="hljs-keyword">in</span> headers) {</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <ul>
<li>Empty header name field is malformed</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (headerName.length &lt;= <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">this</span>.stream.reset(<span class="hljs-string">'PROTOCOL_ERROR'</span>);
      <span class="hljs-keyword">return</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <ul>
<li>A request or response containing uppercase header name field names MUST be
treated as malformed (Section 8.1.3.5). Implementations that detect malformed
requests or responses need to ensure that the stream ends.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span>(<span class="hljs-regexp">/[A-Z]/</span>.test(headerName)) {
      <span class="hljs-keyword">this</span>.stream.reset(<span class="hljs-string">'PROTOCOL_ERROR'</span>);
      <span class="hljs-keyword">return</span>;
    }
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <h2 id="outgoingmessage-class">OutgoingMessage class</h2>

            </div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">OutgoingMessage</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <ul>
<li>This is basically a read-only wrapper for the <a href="protocol/stream.html">Stream</a> class.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Writable.call(<span class="hljs-keyword">this</span>);

  <span class="hljs-keyword">this</span>._headers = {};
  <span class="hljs-keyword">this</span>._trailers = <span class="hljs-literal">undefined</span>;
  <span class="hljs-keyword">this</span>.headersSent = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>.finished = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'finish'</span>, <span class="hljs-keyword">this</span>._finish);
}
OutgoingMessage.prototype = <span class="hljs-built_in">Object</span>.create(Writable.prototype, { constructor: { value: OutgoingMessage } });

OutgoingMessage.prototype._write = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_write</span>(<span class="hljs-params">chunk, encoding, callback</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stream) {
    <span class="hljs-keyword">this</span>.stream.write(chunk, encoding, callback);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.once(<span class="hljs-string">'socket'</span>, <span class="hljs-keyword">this</span>._write.bind(<span class="hljs-keyword">this</span>, chunk, encoding, callback));
  }
};

OutgoingMessage.prototype._finish = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_finish</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stream) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._trailers) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.request) {
        <span class="hljs-keyword">this</span>.request.addTrailers(<span class="hljs-keyword">this</span>._trailers);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.stream.headers(<span class="hljs-keyword">this</span>._trailers);
      }
    }
    <span class="hljs-keyword">this</span>.finished = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.stream.end();
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.once(<span class="hljs-string">'socket'</span>, <span class="hljs-keyword">this</span>._finish.bind(<span class="hljs-keyword">this</span>));
  }
};

OutgoingMessage.prototype.setHeader = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setHeader</span>(<span class="hljs-params">name, value</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.headersSent) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Can\'t set headers after they are sent.'</span>));
  } <span class="hljs-keyword">else</span> {
    name = name.toLowerCase();
    <span class="hljs-keyword">if</span> (deprecatedHeaders.indexOf(name) !== -<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Cannot set deprecated header: '</span> + name));
    }
    <span class="hljs-keyword">this</span>._headers[name] = value;
  }
};

OutgoingMessage.prototype.removeHeader = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeHeader</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.headersSent) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Can\'t remove headers after they are sent.'</span>));
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._headers[name.toLowerCase()];
  }
};

OutgoingMessage.prototype.getHeader = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHeader</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._headers[name.toLowerCase()];
};

OutgoingMessage.prototype.addTrailers = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTrailers</span>(<span class="hljs-params">trailers</span>) </span>{
  <span class="hljs-keyword">this</span>._trailers = trailers;
};

OutgoingMessage.prototype.setTimeout = noop;

OutgoingMessage.prototype._checkSpecialHeader = IncomingMessage.prototype._checkSpecialHeader;</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <h1 id="server-side">Server side</h1>

            </div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
exports.Server = Server;
exports.IncomingRequest = IncomingRequest;
exports.OutgoingResponse = OutgoingResponse;
exports.ServerResponse = OutgoingResponse; <span class="hljs-comment">// for API compatibility</span></pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Forward events <code>event</code> on <code>source</code> to all listeners on <code>target</code>.</p>
<p>Note: The calling context is <code>source</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forwardEvent</span>(<span class="hljs-params">event, source, target</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forward</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> listeners = target.listeners(event);

    <span class="hljs-keyword">var</span> n = listeners.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Special case for <code>error</code> event with no listeners.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span> &amp;&amp; event === <span class="hljs-string">'error'</span>) {
      <span class="hljs-keyword">var</span> args = [event];
      args.push.apply(args, <span class="hljs-built_in">arguments</span>);

      target.emit.apply(target, args);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
      listeners[i].apply(source, <span class="hljs-built_in">arguments</span>);
    }
  }

  source.on(event, forward);</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>A reference to the function is necessary to be able to stop
forwarding.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">return</span> forward;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <h2 id="server-class">Server class</h2>

            </div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Server</span>(<span class="hljs-params">options</span>) </span>{
  options = util._extend({}, options);

  <span class="hljs-keyword">this</span>._log = (options.log || defaultLogger).child({ component: <span class="hljs-string">'http'</span> });
  <span class="hljs-keyword">this</span>._settings = options.settings;

  <span class="hljs-keyword">var</span> start = <span class="hljs-keyword">this</span>._start.bind(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">var</span> fallback = <span class="hljs-keyword">this</span>._fallback.bind(<span class="hljs-keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>HTTP2 over TLS (using NPN or ALPN)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> ((options.key &amp;&amp; options.cert) || options.pfx) {
    <span class="hljs-keyword">this</span>._log.info(<span class="hljs-string">'Creating HTTP/2 server over TLS'</span>);
    <span class="hljs-keyword">this</span>._mode = <span class="hljs-string">'tls'</span>;
    options.ALPNProtocols = supportedProtocols;
    options.NPNProtocols = supportedProtocols;
    options.ciphers = options.ciphers || cipherSuites;
    options.honorCipherOrder = (options.honorCipherOrder != <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">this</span>._server = https.createServer(options);
    <span class="hljs-keyword">this</span>._originalSocketListeners = <span class="hljs-keyword">this</span>._server.listeners(<span class="hljs-string">'secureConnection'</span>);
    <span class="hljs-keyword">this</span>._server.removeAllListeners(<span class="hljs-string">'secureConnection'</span>);
    <span class="hljs-keyword">this</span>._server.on(<span class="hljs-string">'secureConnection'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>) </span>{
      <span class="hljs-keyword">var</span> negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>It’s true that the client MUST use SNI, but if it doesn’t, we don’t care, don’t fall back to HTTP/1,
since if the ALPN negotiation is otherwise successful, the client thinks we speak HTTP/2 but we don’t.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (negotiatedProtocol === protocol.VERSION) {
        start(socket);
      } <span class="hljs-keyword">else</span> {
        fallback(socket);
      }
    });
    <span class="hljs-keyword">this</span>._server.on(<span class="hljs-string">'request'</span>, <span class="hljs-keyword">this</span>.emit.bind(<span class="hljs-keyword">this</span>, <span class="hljs-string">'request'</span>));

    forwardEvent(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">this</span>._server, <span class="hljs-keyword">this</span>);
    forwardEvent(<span class="hljs-string">'listening'</span>, <span class="hljs-keyword">this</span>._server, <span class="hljs-keyword">this</span>);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>HTTP2 over plain TCP</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options.plain) {
    <span class="hljs-keyword">this</span>._log.info(<span class="hljs-string">'Creating HTTP/2 server over plain TCP'</span>);
    <span class="hljs-keyword">this</span>._mode = <span class="hljs-string">'plain'</span>;
    <span class="hljs-keyword">this</span>._server = net.createServer(start);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>HTTP/2 with HTTP/1.1 upgrade</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>._log.error(<span class="hljs-string">'Trying to create HTTP/2 server with Upgrade from HTTP/1.1'</span>);
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'HTTP1.1 -&gt; HTTP2 upgrade is not yet supported. Please provide TLS keys.'</span>);
  }

  <span class="hljs-keyword">this</span>._server.on(<span class="hljs-string">'close'</span>, <span class="hljs-keyword">this</span>.emit.bind(<span class="hljs-keyword">this</span>, <span class="hljs-string">'close'</span>));
}
Server.prototype = <span class="hljs-built_in">Object</span>.create(EventEmitter.prototype, { constructor: { value: Server } });</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Starting HTTP/2</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Server.prototype._start = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_start</span>(<span class="hljs-params">socket</span>) </span>{
  <span class="hljs-keyword">var</span> endpoint = <span class="hljs-keyword">new</span> Endpoint(<span class="hljs-keyword">this</span>._log, <span class="hljs-string">'SERVER'</span>, <span class="hljs-keyword">this</span>._settings);

  <span class="hljs-keyword">this</span>._log.info({ e: endpoint,
                   client: socket.remoteAddress + <span class="hljs-string">':'</span> + socket.remotePort,
                   SNI: socket.servername
                 }, <span class="hljs-string">'New incoming HTTP/2 connection'</span>);

  endpoint.pipe(socket).pipe(endpoint);

  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  endpoint.on(<span class="hljs-string">'stream'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_onStream</span>(<span class="hljs-params">stream</span>) </span>{
    <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">new</span> OutgoingResponse(stream);
    <span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> IncomingRequest(stream);</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Some conformance to Node.js Https specs allows to distinguish clients:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    request.remoteAddress = socket.remoteAddress;
    request.remotePort = socket.remotePort;
    request.connection = request.socket = response.socket = socket;

    request.once(<span class="hljs-string">'ready'</span>, self.emit.bind(self, <span class="hljs-string">'request'</span>, request, response));
  });

  endpoint.on(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">this</span>.emit.bind(<span class="hljs-keyword">this</span>, <span class="hljs-string">'clientError'</span>));
  socket.on(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">this</span>.emit.bind(<span class="hljs-keyword">this</span>, <span class="hljs-string">'clientError'</span>));

  <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'connection'</span>, socket, endpoint);
};

Server.prototype._fallback = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fallback</span>(<span class="hljs-params">socket</span>) </span>{
  <span class="hljs-keyword">var</span> negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;

  <span class="hljs-keyword">this</span>._log.info({ client: socket.remoteAddress + <span class="hljs-string">':'</span> + socket.remotePort,
                   protocol: negotiatedProtocol,
                   SNI: socket.servername
                 }, <span class="hljs-string">'Falling back to simple HTTPS'</span>);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>._originalSocketListeners.length; i++) {
    <span class="hljs-keyword">this</span>._originalSocketListeners[i].call(<span class="hljs-keyword">this</span>._server, socket);
  }

  <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'connection'</span>, socket);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>There are <a href="https://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback">3 possible signatures</a> of the <code>listen</code> function. Every arguments is forwarded to
the backing TCP or HTTPS server.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Server.prototype.listen = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listen</span>(<span class="hljs-params">port, hostname</span>) </span>{
  <span class="hljs-keyword">this</span>._log.info({ on: ((<span class="hljs-keyword">typeof</span> hostname === <span class="hljs-string">'string'</span>) ? (hostname + <span class="hljs-string">':'</span> + port) : port) },
                 <span class="hljs-string">'Listening for incoming connections'</span>);
  <span class="hljs-keyword">this</span>._server.listen.apply(<span class="hljs-keyword">this</span>._server, <span class="hljs-built_in">arguments</span>);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._server;
};

Server.prototype.close = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">close</span>(<span class="hljs-params">callback</span>) </span>{
  <span class="hljs-keyword">this</span>._log.info(<span class="hljs-string">'Closing server'</span>);
  <span class="hljs-keyword">this</span>._server.close(callback);
};

Server.prototype.setTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setTimeout</span>(<span class="hljs-params">timeout, callback</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._mode === <span class="hljs-string">'tls'</span>) {
    <span class="hljs-keyword">this</span>._server.setTimeout(timeout, callback);
  }
};

<span class="hljs-built_in">Object</span>.defineProperty(Server.prototype, <span class="hljs-string">'timeout'</span>, {
  get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTimeout</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._mode === <span class="hljs-string">'tls'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._server.timeout;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
    }
  },
  set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setTimeout</span>(<span class="hljs-params">timeout</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._mode === <span class="hljs-string">'tls'</span>) {
      <span class="hljs-keyword">this</span>._server.timeout = timeout;
    }
  }
});</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Overriding <code>EventEmitter</code>‘s <code>on(event, listener)</code> method to forward certain subscriptions to
<code>server</code>.There are events on the <code>http.Server</code> class where it makes difference whether someone is
listening on the event or not. In these cases, we can not simply forward the events from the
<code>server</code> to <code>this</code> since that means a listener. Instead, we forward the subscriptions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Server.prototype.on = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">on</span>(<span class="hljs-params">event, listener</span>) </span>{
  <span class="hljs-keyword">if</span> ((event === <span class="hljs-string">'upgrade'</span>) || (event === <span class="hljs-string">'timeout'</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._server.on(event, listener &amp;&amp; listener.bind(<span class="hljs-keyword">this</span>));
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> EventEmitter.prototype.on.call(<span class="hljs-keyword">this</span>, event, listener);
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p><code>addContext</code> is used to add Server Name Indication contexts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Server.prototype.addContext = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addContext</span>(<span class="hljs-params">hostname, credentials</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._mode === <span class="hljs-string">'tls'</span>) {
    <span class="hljs-keyword">this</span>._server.addContext(hostname, credentials);
  }
};

Server.prototype.address = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">address</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._server.address()
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createServerRaw</span>(<span class="hljs-params">options, requestListener</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'function'</span>) {
    requestListener = options;
    options = {};
  }

  <span class="hljs-keyword">if</span> (options.pfx || (options.key &amp;&amp; options.cert)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'options.pfx, options.key, and options.cert are nonsensical!'</span>);
  }

  options.plain = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">var</span> server = <span class="hljs-keyword">new</span> Server(options);

  <span class="hljs-keyword">if</span> (requestListener) {
    server.on(<span class="hljs-string">'request'</span>, requestListener);
  }

  <span class="hljs-keyword">return</span> server;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createServerTLS</span>(<span class="hljs-params">options, requestListener</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'options are required!'</span>);
  }
  <span class="hljs-keyword">if</span> (!options.pfx &amp;&amp; !(options.key &amp;&amp; options.cert)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'options.pfx or options.key and options.cert are required!'</span>);
  }
  options.plain = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">var</span> server = <span class="hljs-keyword">new</span> Server(options);

  <span class="hljs-keyword">if</span> (requestListener) {
    server.on(<span class="hljs-string">'request'</span>, requestListener);
  }

  <span class="hljs-keyword">return</span> server;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Exposed main interfaces for HTTPS connections (the default)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.https = {};
exports.createServer = exports.https.createServer = createServerTLS;
exports.request = exports.https.request = requestTLS;
exports.get = exports.https.get = getTLS;</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Exposed main interfaces for raw TCP connections (not recommended)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.raw = {};
exports.raw.createServer = createServerRaw;
exports.raw.request = requestRaw;
exports.raw.get = getRaw;</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Exposed main interfaces for HTTP plaintext upgrade connections (not implemented)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notImplemented</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'HTTP UPGRADE is not implemented!'</span>);
}

exports.http = {};
exports.http.createServer = exports.http.request = exports.http.get = notImplemented;</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <h2 id="incomingrequest-class">IncomingRequest class</h2>

            </div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IncomingRequest</span>(<span class="hljs-params">stream</span>) </span>{
  IncomingMessage.call(<span class="hljs-keyword">this</span>, stream);
}
IncomingRequest.prototype = <span class="hljs-built_in">Object</span>.create(IncomingMessage.prototype, { constructor: { value: IncomingRequest } });</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p><a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.3">Request Header Fields</a></p>
<ul>
<li><code>headers</code> argument: HTTP/2.0 request and response header fields carry information as a series
of key-value pairs. This includes the target URI for the request, the status code for the
response, as well as HTTP header fields.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>IncomingRequest.prototype._onHeaders = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_onHeaders</span>(<span class="hljs-params">headers</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <ul>
<li>The “:method” header field includes the HTTP method</li>
<li>The “:scheme” header field includes the scheme portion of the target URI</li>
<li>The “:authority” header field includes the authority portion of the target URI</li>
<li>The “:path” header field includes the path and query parts of the target URI.
This field MUST NOT be empty; URIs that do not contain a path component MUST include a value
of ‘/‘, unless the request is an OPTIONS request for ‘<em>‘, in which case the “:path” header
field MUST include ‘</em>‘.</li>
<li>All HTTP/2.0 requests MUST include exactly one valid value for all of these header fields. A
server MUST treat the absence of any of these header fields, presence of multiple values, or
an invalid value as a stream error of type PROTOCOL_ERROR.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.method = <span class="hljs-keyword">this</span>._checkSpecialHeader(<span class="hljs-string">':method'</span>   , headers[<span class="hljs-string">':method'</span>]);
  <span class="hljs-keyword">this</span>.scheme = <span class="hljs-keyword">this</span>._checkSpecialHeader(<span class="hljs-string">':scheme'</span>   , headers[<span class="hljs-string">':scheme'</span>]);
  <span class="hljs-keyword">this</span>.host   = <span class="hljs-keyword">this</span>._checkSpecialHeader(<span class="hljs-string">':authority'</span>, headers[<span class="hljs-string">':authority'</span>]  );
  <span class="hljs-keyword">this</span>.url    = <span class="hljs-keyword">this</span>._checkSpecialHeader(<span class="hljs-string">':path'</span>     , headers[<span class="hljs-string">':path'</span>]  );
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.method || !<span class="hljs-keyword">this</span>.scheme || !<span class="hljs-keyword">this</span>.host || !<span class="hljs-keyword">this</span>.url) {</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>This is invalid, and we’ve sent a RST_STREAM, so don’t continue processing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <ul>
<li>Host header is included in the headers object for backwards compatibility.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.headers.host = <span class="hljs-keyword">this</span>.host;</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <ul>
<li>Handling regular headers.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  IncomingMessage.prototype._onHeaders.call(<span class="hljs-keyword">this</span>, headers);</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <ul>
<li>Signaling that the headers arrived.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>._log.info({ method: <span class="hljs-keyword">this</span>.method, scheme: <span class="hljs-keyword">this</span>.scheme, host: <span class="hljs-keyword">this</span>.host,
                   path: <span class="hljs-keyword">this</span>.url, headers: <span class="hljs-keyword">this</span>.headers }, <span class="hljs-string">'Incoming request'</span>);
  <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'ready'</span>);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <h2 id="outgoingresponse-class">OutgoingResponse class</h2>

            </div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">OutgoingResponse</span>(<span class="hljs-params">stream</span>) </span>{
  OutgoingMessage.call(<span class="hljs-keyword">this</span>);

  <span class="hljs-keyword">this</span>._log = stream._log.child({ component: <span class="hljs-string">'http'</span> });

  <span class="hljs-keyword">this</span>.stream = stream;
  <span class="hljs-keyword">this</span>.statusCode = <span class="hljs-number">200</span>;
  <span class="hljs-keyword">this</span>.sendDate = <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">this</span>.stream.once(<span class="hljs-string">'headers'</span>, <span class="hljs-keyword">this</span>._onRequestHeaders.bind(<span class="hljs-keyword">this</span>));
}
OutgoingResponse.prototype = <span class="hljs-built_in">Object</span>.create(OutgoingMessage.prototype, { constructor: { value: OutgoingResponse } });

OutgoingResponse.prototype.writeHead = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeHead</span>(<span class="hljs-params">statusCode, reasonPhrase, headers</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.headersSent) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> reasonPhrase === <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">this</span>._log.warn(<span class="hljs-string">'Reason phrase argument was present but ignored by the writeHead method'</span>);
  } <span class="hljs-keyword">else</span> {
    headers = reasonPhrase;
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> headers) {
    <span class="hljs-keyword">this</span>.setHeader(name, headers[name]);
  }
  headers = <span class="hljs-keyword">this</span>._headers;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sendDate &amp;&amp; !(<span class="hljs-string">'date'</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>._headers)) {
    headers.date = (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).toUTCString();
  }

  <span class="hljs-keyword">this</span>._log.info({ status: statusCode, headers: <span class="hljs-keyword">this</span>._headers }, <span class="hljs-string">'Sending server response'</span>);

  headers[<span class="hljs-string">':status'</span>] = <span class="hljs-keyword">this</span>.statusCode = statusCode;

  <span class="hljs-keyword">this</span>.stream.headers(headers);
  <span class="hljs-keyword">this</span>.headersSent = <span class="hljs-literal">true</span>;
};

OutgoingResponse.prototype._implicitHeaders = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_implicitHeaders</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.headersSent) {
    <span class="hljs-keyword">this</span>.writeHead(<span class="hljs-keyword">this</span>.statusCode);
  }
};

OutgoingResponse.prototype._implicitHeader = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>._implicitHeaders();
};

OutgoingResponse.prototype.write = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">write</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>._implicitHeaders();
  <span class="hljs-keyword">return</span> OutgoingMessage.prototype.write.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
};

OutgoingResponse.prototype.end = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">end</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.finshed = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">this</span>._implicitHeaders();
  <span class="hljs-keyword">return</span> OutgoingMessage.prototype.end.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
};

OutgoingResponse.prototype._onRequestHeaders = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_onRequestHeaders</span>(<span class="hljs-params">headers</span>) </span>{
  <span class="hljs-keyword">this</span>._requestHeaders = headers;
};

OutgoingResponse.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">options</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'string'</span>) {
    options = url.parse(options);
  }

  <span class="hljs-keyword">if</span> (!options.path) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'`path` option is mandatory.'</span>);
  }

  <span class="hljs-keyword">var</span> promise = util._extend({
    <span class="hljs-string">':method'</span>: (options.method || <span class="hljs-string">'GET'</span>).toUpperCase(),
    <span class="hljs-string">':scheme'</span>: (options.protocol &amp;&amp; options.protocol.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)) || <span class="hljs-keyword">this</span>._requestHeaders[<span class="hljs-string">':scheme'</span>],
    <span class="hljs-string">':authority'</span>: options.hostname || options.host || <span class="hljs-keyword">this</span>._requestHeaders[<span class="hljs-string">':authority'</span>],
    <span class="hljs-string">':path'</span>: options.path
  }, options.headers);

  <span class="hljs-keyword">this</span>._log.info({ method: promise[<span class="hljs-string">':method'</span>], scheme: promise[<span class="hljs-string">':scheme'</span>],
                   authority: promise[<span class="hljs-string">':authority'</span>], path: promise[<span class="hljs-string">':path'</span>],
                   headers: options.headers }, <span class="hljs-string">'Promising push stream'</span>);

  <span class="hljs-keyword">var</span> pushStream = <span class="hljs-keyword">this</span>.stream.promise(promise);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OutgoingResponse(pushStream);
};

OutgoingResponse.prototype.altsvc = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">altsvc</span>(<span class="hljs-params">host, port, protocolID, maxAge, origin</span>) </span>{
    <span class="hljs-keyword">if</span> (origin === <span class="hljs-literal">undefined</span>) {
        origin = <span class="hljs-string">""</span>;
    }
    <span class="hljs-keyword">this</span>.stream.altsvc(host, port, protocolID, maxAge, origin);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>Overriding <code>EventEmitter</code>‘s <code>on(event, listener)</code> method to forward certain subscriptions to
<code>request</code>. See <code>Server.prototype.on</code> for explanation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>OutgoingResponse.prototype.on = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">on</span>(<span class="hljs-params">event, listener</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.request &amp;&amp; (event === <span class="hljs-string">'timeout'</span>)) {
    <span class="hljs-keyword">this</span>.request.on(event, listener &amp;&amp; listener.bind(<span class="hljs-keyword">this</span>));
  } <span class="hljs-keyword">else</span> {
    OutgoingMessage.prototype.on.call(<span class="hljs-keyword">this</span>, event, listener);
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <h1 id="client-side">Client side</h1>

            </div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
exports.ClientRequest = OutgoingRequest; <span class="hljs-comment">// for API compatibility</span>
exports.OutgoingRequest = OutgoingRequest;
exports.IncomingResponse = IncomingResponse;
exports.Agent = Agent;
exports.globalAgent = <span class="hljs-literal">undefined</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestRaw</span>(<span class="hljs-params">options, callback</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">"string"</span>) {
    options = url.parse(options);
  }
  options.plain = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">if</span> (options.protocol &amp;&amp; options.protocol !== <span class="hljs-string">"http:"</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'This interface only supports http-schemed URLs'</span>);
  }
  <span class="hljs-keyword">if</span> (options.agent &amp;&amp; <span class="hljs-keyword">typeof</span>(options.agent.request) === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">var</span> agentOptions = util._extend({}, options);
    <span class="hljs-keyword">delete</span> agentOptions.agent;
    <span class="hljs-keyword">return</span> options.agent.request(agentOptions, callback);
  }
  <span class="hljs-keyword">return</span> exports.globalAgent.request(options, callback);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestTLS</span>(<span class="hljs-params">options, callback</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">"string"</span>) {
    options = url.parse(options);
  }
  options.plain = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">if</span> (options.protocol &amp;&amp; options.protocol !== <span class="hljs-string">"https:"</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'This interface only supports https-schemed URLs'</span>);
  }
  <span class="hljs-keyword">if</span> (options.agent &amp;&amp; <span class="hljs-keyword">typeof</span>(options.agent.request) === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">var</span> agentOptions = util._extend({}, options);
    <span class="hljs-keyword">delete</span> agentOptions.agent;
    <span class="hljs-keyword">return</span> options.agent.request(agentOptions, callback);
  }
  <span class="hljs-keyword">return</span> exports.globalAgent.request(options, callback);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRaw</span>(<span class="hljs-params">options, callback</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">"string"</span>) {
    options = url.parse(options);
  }
  options.plain = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">if</span> (options.protocol &amp;&amp; options.protocol !== <span class="hljs-string">"http:"</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'This interface only supports http-schemed URLs'</span>);
  }
  <span class="hljs-keyword">if</span> (options.agent &amp;&amp; <span class="hljs-keyword">typeof</span>(options.agent.get) === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">var</span> agentOptions = util._extend({}, options);
    <span class="hljs-keyword">delete</span> agentOptions.agent;
    <span class="hljs-keyword">return</span> options.agent.get(agentOptions, callback);
  }
  <span class="hljs-keyword">return</span> exports.globalAgent.get(options, callback);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTLS</span>(<span class="hljs-params">options, callback</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">"string"</span>) {
    options = url.parse(options);
  }
  options.plain = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">if</span> (options.protocol &amp;&amp; options.protocol !== <span class="hljs-string">"https:"</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'This interface only supports https-schemed URLs'</span>);
  }
  <span class="hljs-keyword">if</span> (options.agent &amp;&amp; <span class="hljs-keyword">typeof</span>(options.agent.get) === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">var</span> agentOptions = util._extend({}, options);
    <span class="hljs-keyword">delete</span> agentOptions.agent;
    <span class="hljs-keyword">return</span> options.agent.get(agentOptions, callback);
  }
  <span class="hljs-keyword">return</span> exports.globalAgent.get(options, callback);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <h2 id="agent-class">Agent class</h2>

            </div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Agent</span>(<span class="hljs-params">options</span>) </span>{
  EventEmitter.call(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">this</span>.setMaxListeners(<span class="hljs-number">0</span>);

  options = util._extend({}, options);

  <span class="hljs-keyword">this</span>._settings = options.settings;
  <span class="hljs-keyword">this</span>._log = (options.log || defaultLogger).child({ component: <span class="hljs-string">'http'</span> });
  <span class="hljs-keyword">this</span>.endpoints = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <ul>
<li>Using an own HTTPS agent, because the global agent does not look at <code>NPN/ALPNProtocols</code> when
generating the key identifying the connection, so we may get useless non-negotiated TLS
channels even if we ask for a negotiated one. This agent will contain only negotiated
channels.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  options.ALPNProtocols = supportedProtocols;
  options.NPNProtocols = supportedProtocols;
  <span class="hljs-keyword">this</span>._httpsAgent = <span class="hljs-keyword">new</span> https.Agent(options);

  <span class="hljs-keyword">this</span>.sockets = <span class="hljs-keyword">this</span>._httpsAgent.sockets;
  <span class="hljs-keyword">this</span>.requests = <span class="hljs-keyword">this</span>._httpsAgent.requests;
}
Agent.prototype = <span class="hljs-built_in">Object</span>.create(EventEmitter.prototype, { constructor: { value: Agent } });

Agent.prototype.request = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">options, callback</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'string'</span>) {
    options = url.parse(options);
  } <span class="hljs-keyword">else</span> {
    options = util._extend({}, options);
  }

  options.method = (options.method || <span class="hljs-string">'GET'</span>).toUpperCase();
  options.protocol = options.protocol || <span class="hljs-string">'https:'</span>;
  options.host = options.hostname || options.host || <span class="hljs-string">'localhost'</span>;
  options.port = options.port || <span class="hljs-number">443</span>;
  options.path = options.path || <span class="hljs-string">'/'</span>;

  <span class="hljs-keyword">if</span> (!options.plain &amp;&amp; options.protocol === <span class="hljs-string">'http:'</span>) {
    <span class="hljs-keyword">this</span>._log.error(<span class="hljs-string">'Trying to negotiate client request with Upgrade from HTTP/1.1'</span>);
    <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'HTTP1.1 -&gt; HTTP2 upgrade is not yet supported.'</span>));
  }

  <span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> OutgoingRequest(<span class="hljs-keyword">this</span>._log);

  <span class="hljs-keyword">if</span> (callback) {
    request.on(<span class="hljs-string">'response'</span>, callback);
  }

  <span class="hljs-keyword">var</span> key = [
    !!options.plain,
    options.host,
    options.port
  ].join(<span class="hljs-string">':'</span>);
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <ul>
<li>There’s an existing HTTP/2 connection to this host</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.endpoints) {
    <span class="hljs-keyword">var</span> endpoint = <span class="hljs-keyword">this</span>.endpoints[key];
    request._start(endpoint.createStream(), options);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <ul>
<li>HTTP/2 over plain TCP</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options.plain) {
    endpoint = <span class="hljs-keyword">new</span> Endpoint(<span class="hljs-keyword">this</span>._log, <span class="hljs-string">'CLIENT'</span>, <span class="hljs-keyword">this</span>._settings);
    endpoint.socket = net.connect({
      host: options.host,
      port: options.port,
      localAddress: options.localAddress
    });

    endpoint.socket.on(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
      self._log.error(<span class="hljs-string">'Socket error: '</span> + error.toString());
      request.emit(<span class="hljs-string">'error'</span>, error);
    });

    endpoint.on(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)</span>{
      self._log.error(<span class="hljs-string">'Connection error: '</span> + error.toString());
      request.emit(<span class="hljs-string">'error'</span>, error);
    });

    <span class="hljs-keyword">this</span>.endpoints[key] = endpoint;
    endpoint.pipe(endpoint.socket).pipe(endpoint);
    request._start(endpoint.createStream(), options);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <ul>
<li>HTTP/2 over TLS negotiated using NPN or ALPN, or fallback to HTTPS1</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> started = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> createAgent = hasAgentOptions(options);
    options.ALPNProtocols = supportedProtocols;
    options.NPNProtocols = supportedProtocols;
    options.servername = options.host; <span class="hljs-comment">// Server Name Indication</span>
    options.ciphers = options.ciphers || cipherSuites;
    <span class="hljs-keyword">if</span> (createAgent) {
      options.agent = <span class="hljs-keyword">new</span> https.Agent(options);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options.agent == <span class="hljs-literal">null</span>) {
      options.agent = <span class="hljs-keyword">this</span>._httpsAgent;
    }
    <span class="hljs-keyword">var</span> httpsRequest = https.request(options);

    httpsRequest.on(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
      self._log.error(<span class="hljs-string">'Socket error: '</span> + error.toString());
      self.removeAllListeners(key);
      request.emit(<span class="hljs-string">'error'</span>, error);
    });

    httpsRequest.on(<span class="hljs-string">'socket'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>) </span>{
      <span class="hljs-keyword">var</span> negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;
      <span class="hljs-keyword">if</span> (negotiatedProtocol != <span class="hljs-literal">null</span>) { <span class="hljs-comment">// null in &gt;=0.11.0, undefined in &lt;0.11.0</span>
        negotiated();
      } <span class="hljs-keyword">else</span> {
        socket.on(<span class="hljs-string">'secureConnect'</span>, negotiated);
      }
    });

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">negotiated</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> endpoint;
      <span class="hljs-keyword">var</span> negotiatedProtocol = httpsRequest.socket.alpnProtocol || httpsRequest.socket.npnProtocol;
      <span class="hljs-keyword">if</span> (negotiatedProtocol === protocol.VERSION) {
        httpsRequest.socket.emit(<span class="hljs-string">'agentRemove'</span>);
        unbundleSocket(httpsRequest.socket);
        endpoint = <span class="hljs-keyword">new</span> Endpoint(self._log, <span class="hljs-string">'CLIENT'</span>, self._settings);
        endpoint.socket = httpsRequest.socket;
        endpoint.pipe(endpoint.socket).pipe(endpoint);
      }
      <span class="hljs-keyword">if</span> (started) {</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>** In the meantime, an other connection was made to the same host…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (endpoint) {</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p><em>*</em> and it turned out to be HTTP2 and the request was multiplexed on that one, so we should close this one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          endpoint.close();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p><em>*</em> otherwise, the fallback to HTTPS1 is already done.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (endpoint) {
          self._log.info({ e: endpoint, server: options.host + <span class="hljs-string">':'</span> + options.port },
                         <span class="hljs-string">'New outgoing HTTP/2 connection'</span>);
          self.endpoints[key] = endpoint;
          self.emit(key, endpoint);
        } <span class="hljs-keyword">else</span> {
          self.emit(key, <span class="hljs-literal">undefined</span>);
        }
      }
    }

    <span class="hljs-keyword">this</span>.once(key, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">endpoint</span>) </span>{
      started = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">if</span> (endpoint) {
        request._start(endpoint.createStream(), options);
      } <span class="hljs-keyword">else</span> {
        request._fallback(httpsRequest);
      }
    });
  }

  <span class="hljs-keyword">return</span> request;
};

Agent.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">options, callback</span>) </span>{
  <span class="hljs-keyword">var</span> request = <span class="hljs-keyword">this</span>.request(options, callback);
  request.end();
  <span class="hljs-keyword">return</span> request;
};

Agent.prototype.destroy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._httpsAgent) {
    <span class="hljs-keyword">this</span>._httpsAgent.destroy();
  }
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.endpoints) {
    <span class="hljs-keyword">this</span>.endpoints[key].close(error);
  }
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unbundleSocket</span>(<span class="hljs-params">socket</span>) </span>{
  socket.removeAllListeners(<span class="hljs-string">'data'</span>);
  socket.removeAllListeners(<span class="hljs-string">'end'</span>);
  socket.removeAllListeners(<span class="hljs-string">'readable'</span>);
  socket.removeAllListeners(<span class="hljs-string">'close'</span>);
  socket.removeAllListeners(<span class="hljs-string">'error'</span>);
  socket.unpipe();
  <span class="hljs-keyword">delete</span> socket.ondata;
  <span class="hljs-keyword">delete</span> socket.onend;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasAgentOptions</span>(<span class="hljs-params">options</span>) </span>{
  <span class="hljs-keyword">return</span> options.pfx != <span class="hljs-literal">null</span> ||
    options.key != <span class="hljs-literal">null</span> ||
    options.passphrase != <span class="hljs-literal">null</span> ||
    options.cert != <span class="hljs-literal">null</span> ||
    options.ca != <span class="hljs-literal">null</span> ||
    options.ciphers != <span class="hljs-literal">null</span> ||
    options.rejectUnauthorized != <span class="hljs-literal">null</span> ||
    options.secureProtocol != <span class="hljs-literal">null</span>;
}

<span class="hljs-built_in">Object</span>.defineProperty(Agent.prototype, <span class="hljs-string">'maxSockets'</span>, {
  get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMaxSockets</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._httpsAgent.maxSockets;
  },
  set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setMaxSockets</span>(<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">this</span>._httpsAgent.maxSockets = value;
  }
});

exports.globalAgent = <span class="hljs-keyword">new</span> Agent();</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <h2 id="outgoingrequest-class">OutgoingRequest class</h2>

            </div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">OutgoingRequest</span>(<span class="hljs-params"></span>) </span>{
  OutgoingMessage.call(<span class="hljs-keyword">this</span>);

  <span class="hljs-keyword">this</span>._log = <span class="hljs-literal">undefined</span>;

  <span class="hljs-keyword">this</span>.stream = <span class="hljs-literal">undefined</span>;
}
OutgoingRequest.prototype = <span class="hljs-built_in">Object</span>.create(OutgoingMessage.prototype, { constructor: { value: OutgoingRequest } });

OutgoingRequest.prototype._start = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_start</span>(<span class="hljs-params">stream, options</span>) </span>{
  <span class="hljs-keyword">this</span>.stream = stream;
  <span class="hljs-keyword">this</span>.options = options;

  <span class="hljs-keyword">this</span>._log = stream._log.child({ component: <span class="hljs-string">'http'</span> });

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> options.headers) {
    <span class="hljs-keyword">this</span>.setHeader(key, options.headers[key]);
  }
  <span class="hljs-keyword">var</span> headers = <span class="hljs-keyword">this</span>._headers;
  <span class="hljs-keyword">delete</span> headers.host;

  <span class="hljs-keyword">if</span> (options.auth) {
    headers.authorization = <span class="hljs-string">'Basic '</span> + <span class="hljs-keyword">new</span> Buffer(options.auth).toString(<span class="hljs-string">'base64'</span>);
  }

  headers[<span class="hljs-string">':scheme'</span>] = options.protocol.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);
  headers[<span class="hljs-string">':method'</span>] = options.method;
  headers[<span class="hljs-string">':authority'</span>] = options.host;
  headers[<span class="hljs-string">':path'</span>] = options.path;

  <span class="hljs-keyword">this</span>._log.info({ scheme: headers[<span class="hljs-string">':scheme'</span>], method: headers[<span class="hljs-string">':method'</span>],
                   authority: headers[<span class="hljs-string">':authority'</span>], path: headers[<span class="hljs-string">':path'</span>],
                   headers: (options.headers || {}) }, <span class="hljs-string">'Sending request'</span>);
  <span class="hljs-keyword">this</span>.stream.headers(headers);
  <span class="hljs-keyword">this</span>.headersSent = <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'socket'</span>, <span class="hljs-keyword">this</span>.stream);
  <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">new</span> IncomingResponse(<span class="hljs-keyword">this</span>.stream);
  response.req = <span class="hljs-keyword">this</span>;
  response.once(<span class="hljs-string">'ready'</span>, <span class="hljs-keyword">this</span>.emit.bind(<span class="hljs-keyword">this</span>, <span class="hljs-string">'response'</span>, response));

  <span class="hljs-keyword">this</span>.stream.on(<span class="hljs-string">'promise'</span>, <span class="hljs-keyword">this</span>._onPromise.bind(<span class="hljs-keyword">this</span>));
};

OutgoingRequest.prototype._fallback = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fallback</span>(<span class="hljs-params">request</span>) </span>{
  request.on(<span class="hljs-string">'response'</span>, <span class="hljs-keyword">this</span>.emit.bind(<span class="hljs-keyword">this</span>, <span class="hljs-string">'response'</span>));
  <span class="hljs-keyword">this</span>.stream = <span class="hljs-keyword">this</span>.request = request;
  <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'socket'</span>, <span class="hljs-keyword">this</span>.socket);
};

OutgoingRequest.prototype.setPriority = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setPriority</span>(<span class="hljs-params">priority</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stream) {
    <span class="hljs-keyword">this</span>.stream.priority(priority);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.once(<span class="hljs-string">'socket'</span>, <span class="hljs-keyword">this</span>.setPriority.bind(<span class="hljs-keyword">this</span>, priority));
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>Overriding <code>EventEmitter</code>‘s <code>on(event, listener)</code> method to forward certain subscriptions to
<code>request</code>. See <code>Server.prototype.on</code> for explanation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>OutgoingRequest.prototype.on = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">on</span>(<span class="hljs-params">event, listener</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.request &amp;&amp; (event === <span class="hljs-string">'upgrade'</span>)) {
    <span class="hljs-keyword">this</span>.request.on(event, listener &amp;&amp; listener.bind(<span class="hljs-keyword">this</span>));
  } <span class="hljs-keyword">else</span> {
    OutgoingMessage.prototype.on.call(<span class="hljs-keyword">this</span>, event, listener);
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Methods only in fallback mode</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>OutgoingRequest.prototype.setNoDelay = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setNoDelay</span>(<span class="hljs-params">noDelay</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.request) {
    <span class="hljs-keyword">this</span>.request.setNoDelay(noDelay);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.stream) {
    <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'socket'</span>, <span class="hljs-keyword">this</span>.setNoDelay.bind(<span class="hljs-keyword">this</span>, noDelay));
  }
};

OutgoingRequest.prototype.setSocketKeepAlive = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setSocketKeepAlive</span>(<span class="hljs-params">enable, initialDelay</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.request) {
    <span class="hljs-keyword">this</span>.request.setSocketKeepAlive(enable, initialDelay);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.stream) {
    <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'socket'</span>, <span class="hljs-keyword">this</span>.setSocketKeepAlive.bind(<span class="hljs-keyword">this</span>, enable, initialDelay));
  }
};

OutgoingRequest.prototype.setTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setTimeout</span>(<span class="hljs-params">timeout, callback</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.request) {
    <span class="hljs-keyword">this</span>.request.setTimeout(timeout, callback);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.stream) {
    <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'socket'</span>, <span class="hljs-keyword">this</span>.setTimeout.bind(<span class="hljs-keyword">this</span>, timeout, callback));
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>Aborting the request</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>OutgoingRequest.prototype.abort = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abort</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.request) {
    <span class="hljs-keyword">this</span>.request.abort();
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stream) {
    <span class="hljs-keyword">this</span>.stream.reset(<span class="hljs-string">'CANCEL'</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'socket'</span>, <span class="hljs-keyword">this</span>.abort.bind(<span class="hljs-keyword">this</span>));
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Receiving push promises</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>OutgoingRequest.prototype._onPromise = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_onPromise</span>(<span class="hljs-params">stream, headers</span>) </span>{
  <span class="hljs-keyword">this</span>._log.info({ push_stream: stream.id }, <span class="hljs-string">'Receiving push promise'</span>);

  <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> IncomingPromise(stream, headers);

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.listeners(<span class="hljs-string">'push'</span>).length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'push'</span>, promise);
  } <span class="hljs-keyword">else</span> {
    promise.cancel();
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <h2 id="incomingresponse-class">IncomingResponse class</h2>

            </div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IncomingResponse</span>(<span class="hljs-params">stream</span>) </span>{
  IncomingMessage.call(<span class="hljs-keyword">this</span>, stream);
}
IncomingResponse.prototype = <span class="hljs-built_in">Object</span>.create(IncomingMessage.prototype, { constructor: { value: IncomingResponse } });</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p><a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.4">Response Header Fields</a></p>
<ul>
<li><code>headers</code> argument: HTTP/2.0 request and response header fields carry information as a series
of key-value pairs. This includes the target URI for the request, the status code for the
response, as well as HTTP header fields.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>IncomingResponse.prototype._onHeaders = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_onHeaders</span>(<span class="hljs-params">headers</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <ul>
<li>A single “:status” header field is defined that carries the HTTP status code field. This
header field MUST be included in all responses.</li>
<li>A client MUST treat the absence of the “:status” header field, the presence of multiple
values, or an invalid value as a stream error of type PROTOCOL_ERROR.
Note: currently, we do not enforce it strictly: we accept any format, and parse it as int</li>
<li>HTTP/2.0 does not define a way to carry the reason phrase that is included in an HTTP/1.1
status line.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.statusCode = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">this</span>._checkSpecialHeader(<span class="hljs-string">':status'</span>, headers[<span class="hljs-string">':status'</span>]));</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <ul>
<li>Handling regular headers.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  IncomingMessage.prototype._onHeaders.call(<span class="hljs-keyword">this</span>, headers);</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <ul>
<li>Signaling that the headers arrived.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>._log.info({ status: <span class="hljs-keyword">this</span>.statusCode, headers: <span class="hljs-keyword">this</span>.headers}, <span class="hljs-string">'Incoming response'</span>);
  <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'ready'</span>);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <h2 id="incomingpromise-class">IncomingPromise class</h2>

            </div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IncomingPromise</span>(<span class="hljs-params">responseStream, promiseHeaders</span>) </span>{
  <span class="hljs-keyword">var</span> stream = <span class="hljs-keyword">new</span> Readable();
  stream._read = noop;
  stream.push(<span class="hljs-literal">null</span>);
  stream._log = responseStream._log;

  IncomingRequest.call(<span class="hljs-keyword">this</span>, stream);

  <span class="hljs-keyword">this</span>._onHeaders(promiseHeaders);

  <span class="hljs-keyword">this</span>._responseStream = responseStream;

  <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">new</span> IncomingResponse(<span class="hljs-keyword">this</span>._responseStream);
  response.once(<span class="hljs-string">'ready'</span>, <span class="hljs-keyword">this</span>.emit.bind(<span class="hljs-keyword">this</span>, <span class="hljs-string">'response'</span>, response));

  <span class="hljs-keyword">this</span>.stream.on(<span class="hljs-string">'promise'</span>, <span class="hljs-keyword">this</span>._onPromise.bind(<span class="hljs-keyword">this</span>));
}
IncomingPromise.prototype = <span class="hljs-built_in">Object</span>.create(IncomingRequest.prototype, { constructor: { value: IncomingPromise } });

IncomingPromise.prototype.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancel</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>._responseStream.reset(<span class="hljs-string">'CANCEL'</span>);
};

IncomingPromise.prototype.setPriority = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setPriority</span>(<span class="hljs-params">priority</span>) </span>{
  <span class="hljs-keyword">this</span>._responseStream.priority(priority);
};

IncomingPromise.prototype._onPromise = OutgoingRequest.prototype._onPromise;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
